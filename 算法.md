# 算法

冒泡排序：平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。

选择排序：平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，不是稳定排序。

插入排序：平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。

- 最好情况是已排序序列，时间复杂度是O(n)

归并排序：平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(n) ，是稳定排序。

堆排序：将序列构造成最大堆，然后将顶点值与末尾值交换，对剩余的n-1个元素重新构造最大堆，以此达到排序目的。平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(1) ，不是稳定排序。

希尔排序：利用插入排序对已排序序列最好的特点，设置增量分成小组进行基数排序，然后再逐步增大增量达到排序的目的。平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n^2) ，空间复杂度为 O(1) ，不是稳定排序。

基数排序：将所有数值按数位划分，位数不足时补零。从最低位开始排序，每一次排序都基于上一次结果，一直到最高位排序结束得到有序数列。平均时间复杂度为 O(nk)，k 为最大元素的长度，最坏时间复杂度为 O(nk)，空间复杂度为 O(n) ，是稳定排序。

快速排序：平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(logn) ，不是稳定排序

- 快速排序在划分平均，递归深度为logn时最优

- 在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，另一个为空。此时需要执行n‐1次递归调用，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是枢轴的位置。

  

  

  